## SJTU-ICS-2017 lab7 攻略 
### 补充说明
* **上一次lab6的攻略延续**
* **是的没错，连markdown我都是复制粘贴改一改的**
* **这次骚操作少一些，但是调试技术很关键...**

### 常规步骤
#### 添加双向空闲块链表  
* 当分配块越来越多，总是从头开始寻找空闲块效率很低，所以额外做一个空闲块链表
* 链表实现参照书上：4bytes头，8bytes前项指针，8bytes后项指针，4bytes尾 
* 即最小的空闲块有24字节

#### 注意事项
* 双向链表！双向链表！双向链表！！！
* 去除任何一项，考虑三种可能：头指针，中间指针，尾指针。
* 假如使用了全局的头指针记录，那么去掉头指针，只需要简单修改一下全局变量
* 中间指针，要注意前后两个指针的指向都要修改
* 尾指针，将前项的后指针变为null即可

#### 修改方式参考
* 当增加一项时，直接从头部插入，即全局头指针指向新指针，新指针的后项指向以前的头，并且之前的头前项为新指针，注意判断条件，之前的头为null的话就省掉一步
* 空闲块合并的时候，合并前面的空闲块时，很简单，只要将前面空闲块size增加就可以了，因为它具有链表结构，不需要做修改
* 合并后面的空闲块，要去掉后项在链表中的位置，并且重新插入新指针
* 前后同时合并，删除后面的，同时增加前面的size即可
* 不使用best-fit策略，直接first-fit的话，经常会空闲块比需求要大，这时候会分裂出一个空闲块，建议将尾部作为分配，这样就不需要修改链表结构了，因为切出来的空闲块直接继承之前的结构即可

### 加分操作一
* 当来到这一步时，分数大约在60~85之间了
* 一般来说，这时候，11个case中，后四个的利用率和速度是很低的
* 先说倒数两个，realloc：如果打开看文件的话，它是不断要更大的位置，同时还插入小碎片，导致块自己不能扩大，每次都要重新分配，并且memcopy
* 处理办法应该很多，讲简单的：在realloc函数，不用修改原来的代码，在它前面插入一段新的代码和条件分支：如果需要realloc的块，在栈（即mem_brk）的尾部，那么此时不需要申请新的malloc，也不需要copy，多申请一些空间，将栈尾挪动一下，调整一下块size即可
* 完成这一步，至少有90分

### 加分操作二
* 7、8两个case，打开来看，是等间距free，留下巨量碎片...
* 等于说是在搞我咯？
* 粗暴办法：每次向mem要空间的时候，统一要大一点的，比如512（具体数字对分数有影响，但不影响满分...）
* 这样，能保证经过几次find fail就能获得一些空闲块
* 紧接着，设置一个全局的指针cache_ptr，该指针每次记录find_fit成功的时候找到的块，也就是被用来分配的空闲块
* 因为空闲块至少有几百字节，所以一般不会直接用完
* 在find_fit的条件判断处（就是size啊，非null什么的判断），加一个：!= cache_ptr
* 比较简单地保证相邻的malloc在地址上不会相邻，也就不会产生大量碎片

### 功成...
* 一般来讲，在玩指针的时候，很容易崩，要有耐心，调试要慢..
* 源代码lab7截止时会上传

### 二次补充说明
* 因为某些trace的设置实在诡异，能够将整个分配速度给拖高（平均值），经过测试发现，不需要做空闲块链表也能拿到95分以上
* 叙述起来有些绕，大致如下：1.place切后部分 2.设置cacheptr避免相邻 3.realloc栈尾不copy
* 见两份源代码



